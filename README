Here we can add the documentation of the program...


check_hours(text) and check_minutes(text): Checking if a given text represents an hour or a minute measure.

check_to(description) and check_past(description): Checking for expressions like "<minute> to <hour>" or "<minute> past <hour>" 

parse_interval(string): Parse a string of the form "<number> <time unit> <number> <time unit> ..." 

word_to_number(word): Convert a word representation of a number to a number.

check_ago(description): Check for expressions like "<number> <time unit> ago" 

check_tomorrow(description) and check_in_future(description, current_time): Checking for expressions like "<day> tomorrow" or "in <time>".

convert_fractions(description): Convert common fractions like "quarter" and "half" to their numerical versions.

check_oclock(description) and check_basic_time(description): Checking for "<hour> o'clock" or a basic time expression 

check_next(description) and check_last(description): Checking for expressions like "next <day>" or "last <day>" and return the corresponding date.

check_easter(description), check_ramadan(description), and check_hebrew_new_year(description): Check for specific holidays.

parse_point_time(description): Parse a description of a single datetime point and return a datetime object.

check_from_to(description) and check_for(description): Checking for expressions like "from <datetime1> to <datetime2>" or "<datetime> for <interval>" 

parse_time(description): It converts the input description to lowercase, applies some preprocessing, and then checks for various time-related patterns using the helper functions.


Jonas has taken care of creating a general background for the functions. He decided to use Rejects. 



Ness also used rejects to great functions ago, next, last, past, tomorrow and in future. The also focused on creating a delta and translating the words to integers.
Proposition division of tasks:

Person1:
Jonas

Introductory function - Parsing dates & times
Points in time

Your function should at least be able to parse the following:

four o'clock
ten past two
five to ten
a quarter to three

Person2:
Ness

three weeks ago
ten minutes ago
in twenty minutes' time
next Tuesday
last Friday
tomorrow at half three


Person3:
Tudor

Durations and Repeating events

A duration has a start time and an end time. You might represent that as a tuple containing two datetimes. A repeating event could be represented as a list of such durations, in case of a finite number of repetitions, or a tuple consisting of a datetime and a timedelta, in the case of an indefinitely repeating event.

next Friday at noon for half an hour
every Thursday at three
every Monday in September at four thirty.
the first Monday of every month at quarter to six


Person4:
Iga

Irregular dates such as Easter

If you want to be really ambitious, you could also parse expressions such as written by the Venerable Bede in the year 725. He determined the date of Easter in the Christian calendar to be

The Sunday following the full Moon which falls on or after the vernal equinox.

Of course, to do this you'll need to find a Python library that gives phases of the moon.

Dates such as the start of the month of Ramadan or the start of the Hebrew new year are even more challenging.


Sources:

Walrus operator, to call function and save return value within an if-statement
https://chat.openai.com/share/7dd6aba1-fa43-46cf-88e5-b298a96d0de0

Regular expression manual
https://docs.python.org/3/howto/regex.html

PyEphem Library to find full moon and quinoxes
https://rhodesmill.org/pyephem/quick.html

Defining the start date of Ramadan as one day after the new moon
https://en.wikipedia.org/wiki/Ramadan#Important_dates

Documentation on the jewish library (allows for easy calendar conversions and calculations)
https://github.com/emosenkis/jewish/blob/master/setup.py